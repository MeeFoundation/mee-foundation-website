---
import Background from './Background.astro';

export interface Props {
}

const {  } = Astro.props;
const subtitles = [
	"there is an online power imbalance.",
	"you can’t control who has your data or how they’ll use it.",
	"data brokers and marketers are buying and selling information about you without your knowledge.",
	"businesses treat your data as their property.",
	"many users navigate this world with mistrust and fear."]
---

<article id="today" class="flex today flex-col items-center">
	{/* <img id="linesImage" class="lines animate-fadeIn" src="/images/lines.svg" /> */}
  <section class="relative z-100 flex flex-col items-center text-center w-full md:w-[692px]">
		<Background />
    <div id="title" class="title overflow-hidden fixed z-100 flex items-center justify-center h-screen pb-7">
			<div class="overflow-hidden">
				<h2 class="text text-base leading-5 font-bold tracking-wider uppercase text-purple animate-riseIn animation-delay-400">In today’s digital world...</h2>
			</div>
    </div>
		<div class="scroll-smooth">
			{subtitles.map(subtitle => (
				<div class="section flex flex-col items-center section-0 overflow-hidden h-[200vh] mb-4">
					<div class="overflow-hidden fixed z-100 top-[50vh] w-full px-5 md:w-[692px]">
						<h2 class="text subtitle text-xl md:text-3xl font-bold text-white/[.85] hidden">{subtitle}</h2>
					</div>
				</div>
			))}
		</div>
		<div class="fixed flex items-center justify-center h-screen pt-52 z-20 animate-fadeIn-long animation-delay-1000">
			<i class="scrollIcon flex relative w-4 h-6 md:w-4.5 md:h-7 py-1 md:py-2 transition-opacity ease-linear duration-100 overflow-hidden"/>
		</div>
		<div id="bleachAnimation" class="flex h-[400vh]">
			<div id="animationTrigger" class="section flex flex-col items-center section-0 overflow-hidden h-screen"/>
		</div>
  </section>
</article>

<style>
	.text {
		-webkit-font-smoothing: antialiased;
		font-smoothing: antialiased;  
	}
	.logo {
		animation-duration: 800ms;
		opacity: 0;
	}
	.title {
		animation-duration: 300ms;
	}
	.subtitle {
		transition: opacity 300ms;
	}

	.scrollIcon {
    border: 2px solid rgba(255,255,255,0.7);
    border-radius: 12px;
	}
	.titleBleach {
		animation-delay: calc(var(--bleachProgress) * 10 * -400ms);
		animation-play-state: paused;
		animation-fill-mode: both;
    backface-visibility: hidden; 
	}
	.figuresBleach {
		animation-delay: calc(var(--bleachProgress) * 2 * -1.5s);
		animation-play-state: paused;
		animation-fill-mode: both;
    backface-visibility: hidden; 
	}
  .scrollIcon::after {
    position: relative;
    left:calc(50% - 1px);
    width: 2px;
    height: 50%;
    background: rgba(255,255,255,0.7);
    border-radius: 1px;
    content:"";
		align-self: flex-start;
    animation-name: scroll;
    animation-duration: 2s;
    animation-iteration-count: infinite;
    animation-delay: 2s;
  }

	@keyframes scroll {
		0% { opacity: 1; height: 50%;}
		20% { opacity: 1; height: 50%;}
		30% { height: 100%; align-self: flex-start;}
		40% { opacity: 1; align-self: flex-end;}
		80% {  opacity: 0; height: 0%; align-self: flex-end;}
		81% {  opacity: 0; height: 50%; align-self: flex-start;}
		100% { opacity: 1; height: 50%;}
	}

</style>

<script>
	import { disableScroll, enableScroll, isScrollStopped, storeScroll } from "../scripts/global";

  const sections = document.querySelectorAll('.today .section');
	const scrollIcon = document.querySelector(".scrollIcon");
	const shadow = document.querySelector(".shadow");
	const title = document.getElementById("title");
	const figuresContainer = document.querySelector('.figuresContainer') as HTMLElement;
	const floatingFigures = document.querySelector('.floatingFigures');
	const grid = document.querySelector('.grid');
	const gradients = document.querySelectorAll('.floatGradient');
	const mainLogo = document.getElementById("mainLogo");
	const todaySection = document.getElementById("today");
	const envisionSection = document.getElementById("envision");
	const bleachSection = document.getElementById("bleachAnimation");

	let scrollSpeed = 4;

	let scrollY = window.scrollY;
	let targetEl: Element | null | undefined;
	let scrollFiguresProgress = 0;
	let isScroll = false;
	let lastTimeStamp: number;

	const getAverage = (numbers: number[]) => numbers.reduce((acc, number) => acc + number, 0) / numbers.length;

	const wheelHandler = (e: WheelEvent) => {
			scrollFiguresProgress += e.deltaY * 0.4;
			if(!isScroll) {
				isScroll = true;
				const currentSlide = document.querySelector('.currentSection');
				let nextSlide = currentSlide?.nextElementSibling;
				let prevSlide = currentSlide?.previousElementSibling;
				if(currentSlide?.classList.contains('textsSection')) {
					nextSlide = currentSlide.querySelector('.currentTextSection')?.nextElementSibling || currentSlide?.nextElementSibling;
					prevSlide = currentSlide.querySelector('.currentTextSection')?.previousElementSibling || currentSlide?.previousElementSibling;
				}
				// if (e.deltaY < 0) scrollY = prevSlide?.scrollTop;
				if (e.deltaY < 0) targetEl = prevSlide;
				// if (e.deltaY > 0) scrollY = nextSlide?.scrollTop;
				if (e.deltaY > 0) targetEl = nextSlide;

				console.log(targetEl);
			}
			if(e.timeStamp - lastTimeStamp > 40 ) {
				isScroll = false;
			}
			// console.log(e.timeStamp - lastTimeStamp)

			lastTimeStamp = e.timeStamp;
		};


		const options: IntersectionObserverInit = {
			// root: document.body,
			threshold: 0.1,
			rootMargin: "-99% 0% 0%"
		};
		const observer = new IntersectionObserver((entries, _) => {
			entries.forEach((entry) => {
				if (entry.isIntersecting) {
					if(entry.target.id === "animationTrigger") {
						title?.classList.add("animate-fadeOut", "titleBleach");
						entry.target.querySelector('.subtitle')?.classList.add("animate-fadeOut", "titleBleach");
						grid?.classList.add("animate-fadeOut", "figuresBleach");
						// figuresContainer?.classList.add("animate-collapse3d", "figuresBleach");
						gradients.forEach(gradient => {gradient.removeAttribute('style');gradient.classList.add("animate-fadeOut", "figuresBleach")})
						shadow?.classList.add("bg-1");
					} else {
						entry.target.querySelector(".subtitle")?.classList.remove('animate-fadeOut','hidden');
						entry.target.querySelector(".subtitle")?.classList.add('animate-riseIn');
						entry.target.classList.add('currentSection');
					}
				} else {
					entry.target.querySelector(".subtitle")?.classList.add('animate-fadeOut','hidden');
					entry.target.querySelector(".subtitle")?.classList.remove('animate-riseIn');
					entry.target.classList.remove('currentSection');
				}
			})
		}, options);

		sections.forEach((section) => {
			observer.observe(section)
		});

		window.addEventListener('wheel', wheelHandler);
		
		document.addEventListener('scroll', (e: Event) => {
			// if(!isScrollStopped) storeScroll(scrollFiguresProgress);

			if(targetEl) targetEl.scrollIntoView({behavior: 'auto'});

			// if(scrollY && scrollY !== window.scrollY) window.scrollTo({left: 0, top: scrollY});

			if(bleachSection) {
				const animationScroll = calcElScroll(bleachSection);
				document.documentElement.style.setProperty('--scaleFactor', calcScale(bleachSection).toString());
				document.documentElement.style.setProperty('--bleachProgress', animationScroll.toString());
				if(animationScroll === 1) {
					// envisionSection?.classList.remove("hidden");
					envisionSection?.classList.remove("opacity-0");
					todaySection?.classList.add('translate-y-0'); // Hack for remove border shadow between today and envision
					mainLogo?.classList.add("logo--contrast");
					// window.removeEventListener('wheel', wheelHandler);
				} else {
					// envisionSection?.classList.add("hidden");
					envisionSection?.classList.add("opacity-0");
					todaySection?.classList.remove('translate-y-0');
					mainLogo?.classList.remove("logo--contrast");
					// window.addEventListener('wheel', wheelHandler);
				}
			}
			if(window.scrollY > 400) {
				scrollIcon?.classList.add("opacity-0");
				setTimeout(()=>{
					scrollIcon?.classList.add("hidden");
				},400)
			}
		})

	const calcElScroll = (element:Element | HTMLElement) => {
		const rect = element.getBoundingClientRect();
		if(rect.top - window.innerHeight > 0) return 0;
		if((rect.bottom - window.innerHeight) < 0) return 1;
		return (Math.abs(rect.top - window.innerHeight)) / rect.height; 
	}
	const calcScale = (element:Element | HTMLElement) => {
		const rect = element.getBoundingClientRect();
		if(rect.top - window.innerHeight > 0) return 1;
		if((rect.bottom - window.innerHeight) < 0) return 0;
		const result = Math.abs(rect.bottom - window.innerHeight) / rect.height;
		return Math.pow(result, 3); 
	}
</script>
